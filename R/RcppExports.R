# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

weeks_1979 <- function(lag, D, L, precision = 1e-8) {
    .Call(`_waterlevel_weeks_1979`, lag, D, L, precision)
}

#' @title
#' vadose_response
#'
#' @description
#' weeks_1979 1-D air diffusivity
#'
#' @param time \code{numeric} value of elapsed time
#' @param D \code{numeric} unsaturated zone air diffusivity
#' @param L \code{numeric} unsaturated zone thickness
#' @param precision \code{numeric} precision of solution
#'
#' @return brf from weeks 1979 model
#'
#'
#' @export
#'
vadose_response <- function(time, D, L, precision = 1e-8) {
    .Call(`_waterlevel_vadose_response`, time, D, L, precision)
}

#' harmonic
#'
#' calculate sin and cos curves from POSIXct times (serial)
#'
#' @param times \code{numeric vector} times to calculate sin and cos at
#' @param freq \code{numeric vector} frequencies for sin and cos
#'
#' @return sin and cos curves
#'
#'
#' @export
#'
harmonic <- function(times, freq) {
    .Call(`_waterlevel_harmonic`, times, freq)
}

check_lag <- function(n, lag, n_shift) {
    .Call(`_waterlevel_check_lag`, n, lag, n_shift)
}

get_length <- function(n, n_subset) {
    .Call(`_waterlevel_get_length`, n, n_subset)
}

get_start <- function(n_out, lag, n_subset) {
    .Call(`_waterlevel_get_start`, n_out, lag, n_subset)
}

get_end <- function(n, n_out, lag, n_subset) {
    .Call(`_waterlevel_get_end`, n, n_out, lag, n_subset)
}

#' @title
#' shift_subset
#'
#' @description
#' lag data and subset the results
#'
#' @param x \code{numeric vector} to lag
#' @param lag \code{integer vector} with the lags
#' @param n_subset \code{integer} subset every n_subset values
#' @param n_shift \code{integer} amount to shift results
#'
#' @return vector with lagged values
#'
#'
#' @export
shift_subset <- function(x, lag = 0L, n_subset = 1L, n_shift = 0L) {
    .Call(`_waterlevel_shift_subset`, x, lag, n_subset, n_shift)
}

#' @title
#' lag_matrix
#'
#' @description
#' lag data and subset the results
#'
#' @param x \code{numeric vector} to lag
#' @param lags \code{integer vector} with the lags
#' @param n_subset \code{integer} subset every n_subset values
#' @param n_shift \code{integer} amount to shift results
#' @param var_name \code{character} name for the generated matrix columns
#'
#' @return matrix with lagged values
#'
#'
#' @export
lag_matrix <- function(x, lags, n_subset = 1L, n_shift = 0L, var_name = "lag") {
    .Call(`_waterlevel_lag_matrix`, x, lags, n_subset, n_shift, var_name)
}

#' @title
#' distributed_lag_parallel
#'
#' @description
#' This method calculates the basis for a distributed lag in parallel.  It is currently
#' slow.
#'
#' @param x matrix value of lag
#' @param bl matrix the basis lags
#' @param lag_max integer maximum number of lags
#' @param n_subset integer subset the data
#' @param n_shift integer to shift
#'
#' @return distributed lag basis
#'
#'
#' @export
#'
distributed_lag_parallel <- function(x, bl, lag_max, n_subset = 1L, n_shift = 0L) {
    .Call(`_waterlevel_distributed_lag_parallel`, x, bl, lag_max, n_subset, n_shift)
}

#' @title
#' det_parallel
#'
#' @description
#' Determinant for an array in parallel
#'
#' @param a \code{numeric array} values to evaluate
#'
#' @return vector of determinants
#'
#'
#' @export
det_parallel <- function(a) {
    .Call(`_waterlevel_det_parallel`, a)
}

#' @title
#' solve_tf_parallel
#'
#' @description
#' Calculate the transfer functions for an array in parallel
#'
#' @param a \code{numeric array} values to evaluate
#'
#' @return vector of transfer functions
#'
#'
#' @export
solve_tf_parallel <- function(a) {
    .Call(`_waterlevel_solve_tf_parallel`, a)
}

calc_b_vals <- function(b, wb) {
    .Call(`_waterlevel_calc_b_vals`, b, wb)
}

konno_ohmachi <- function(b_vals, ref_z, f, x, i) {
    .Call(`_waterlevel_konno_ohmachi`, b_vals, ref_z, f, x, i)
}

#' @title
#' konno_ohmachi_parallel
#'
#' @description
#' This method does konno ohmachi smoothing
#'
#' @param x vector to smooth
#' @param f vector of frequencies
#' @param b integer even magnitude to smooth
#'
#' @return konno ohmachi smoothed results
#'
#'
#' @export
#'
konno_ohmachi_parallel <- function(x, f, b = 10L) {
    .Call(`_waterlevel_konno_ohmachi_parallel`, x, f, b)
}

#' @title
#' konno_ohmachi_serial
#'
#' @description
#' This method does konno ohmachi smoothing
#'
#' @param x \code{numeric vector} to smooth
#' @param f \code{numeric vector} of frequencies
#' @param b \code{integer} smoothing coefficient
#'
#' @return vector of konno ohmachi smoothed results
#'
#'
#' @export
#'
konno_ohmachi_serial <- function(x, f, b = 10L) {
    .Call(`_waterlevel_konno_ohmachi_serial`, x, f, b)
}

